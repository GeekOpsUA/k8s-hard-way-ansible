---
- name: Gather network facts
  run_once: true
  block:
    - name: Get api_service_ip
      ansible.builtin.set_fact:
        api_service_ip: "{{ service_cidr[:-4] + '1' }}"

    - name: Print api_service_ip
      ansible.builtin.debug:
        var: api_service_ip

    # Get the private IP address of the control plane and load balancer nodes
    - name: Read /etc/hosts file
      ansible.builtin.slurp:
        src: /etc/hosts
      register: hosts_file_content

    - name: Decode the content
      ansible.builtin.set_fact:
        hosts_file_content_decoded: "{{ hosts_file_content['content'] | b64decode }}"

    - name: Find the block and extract IPs
      ansible.builtin.set_fact:
        block_content: >-
          {{ hosts_file_content_decoded.split('# BEGIN ANSIBLE MANAGED BLOCK')[1].split('# END ANSIBLE MANAGED BLOCK')[0] }}

    - name: Define regex patterns for each host
      ansible.builtin.set_fact:
        "{{ item }}_pattern": "(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\s+{{ item }}"
      loop:
        - controlplane01
        - controlplane02
        - loadbalancer

    - name: Extract IP addresses for specified hosts
      ansible.builtin.set_fact:
        controlplane01_ip: "{{ block_content | regex_search(controlplane01_pattern, '\\1') | first }}"
        controlplane02_ip: "{{ block_content | regex_search(controlplane02_pattern, '\\1') | first }}"
        loadbalancer_ip: "{{ block_content | regex_search(loadbalancer_pattern, '\\1') | first }}"


    - name: Display the extracted IPs
      ansible.builtin.debug:
        msg:
          - "controlplane01: {{ controlplane01_ip }}"
          - "controlplane02: {{ controlplane02_ip }}"
          - "loadbalancer: {{ loadbalancer_ip }}"

- name: Generate Certificate Authority
  run_once: true
  block:
    - name: Create a directories for Certificates
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0700'
      loop:
        - "{{ certs_path }}"
        - "{{ certs_path }}"
        - "{{ certs_path }}"

    - name: Generate a CA private key
      community.crypto.openssl_privatekey:
        path: "{{ certs_path }}/k8s-ca.key"
        type: Ed25519

    - name: Create CSR using the private key
      community.crypto.openssl_csr:
        path: "{{ certs_path }}/k8s-ca.csr"
        privatekey_path: "{{ certs_path }}/k8s-ca.key"
        common_name: "kubernetes"
        organization_name: "Kubernetes"

    - name: Self sign the csr using its own private key
      community.crypto.x509_certificate:
        path: "{{ certs_path }}/k8s-ca.crt"
        privatekey_path: "{{ certs_path }}/k8s-ca.key"
        csr_path: "{{ certs_path }}/k8s-ca.csr"
        provider: selfsigned

- name: Generate Client and Server Certificates
  run_once: true
  block:
    - name: Generate private key for admin user
      community.crypto.openssl_privatekey:
        path: "{{ certs_path }}/admin.key"
        type: Ed25519

    - name: Create CSR using the private key
      community.crypto.openssl_csr:
        path: "{{ certs_path }}/admin.csr"
        privatekey_path: "{{ certs_path }}/admin.key"
        common_name: "admin"
        organization_name: "system:masters"

    - name: Sign certificate for admin user using CA servers private key
      community.crypto.x509_certificate:
        path: "{{ certs_path }}/admin.crt"
        ownca_path: "{{ certs_path }}/k8s-ca.crt"
        ownca_privatekey_path: "{{ certs_path }}/k8s-ca.key"
        csr_path: "{{ certs_path }}/admin.csr"
        provider: ownca

    - name: Generate Controller Manager Client Certificate
      community.crypto.openssl_privatekey:
        path: "{{ certs_path }}/kube-controller-manager.key"
        type: Ed25519

    - name: Create CSR using the private key
      community.crypto.openssl_csr:
        path: "{{ certs_path }}/kube-controller-manager.csr"
        privatekey_path: "{{ certs_path }}/kube-controller-manager.key"
        common_name: "system:kube-controller-manager"
        organization_name: "system:kube-controller-manager"

    - name: Sign certificate for kube-controller-manager using CA servers private key
      community.crypto.x509_certificate:
        path: "{{ certs_path }}/kube-controller-manager.crt"
        ownca_path: "{{ certs_path }}/k8s-ca.crt"
        ownca_privatekey_path: "{{ certs_path }}/k8s-ca.key"
        csr_path: "{{ certs_path }}/kube-controller-manager.csr"
        provider: ownca

    - name: Generate Kube Proxy Client Certificate
      community.crypto.openssl_privatekey:
        path: "{{ certs_path }}/kube-proxy.key"
        type: Ed25519

    - name: Create CSR using the private key
      community.crypto.openssl_csr:
        path: "{{ certs_path }}/kube-proxy.csr"
        privatekey_path: "{{ certs_path }}/kube-proxy.key"
        common_name: "system:kube-proxy"
        organization_name: "system:kube-proxy"

    - name: Sign certificate for kube-proxy using CA servers private key
      community.crypto.x509_certificate:
        path: "{{ certs_path }}/kube-proxy.crt"
        ownca_path: "{{ certs_path }}/k8s-ca.crt"
        ownca_privatekey_path: "{{ certs_path }}/k8s-ca.key"
        csr_path: "{{ certs_path }}/kube-proxy.csr"
        provider: ownca

    - name: Generate Scheduler Client Certificate
      community.crypto.openssl_privatekey:
        path: "{{ certs_path }}/kube-scheduler.key"
        type: Ed25519

    - name: Create CSR using the private key
      community.crypto.openssl_csr:
        path: "{{ certs_path }}/kube-scheduler.csr"
        privatekey_path: "{{ certs_path }}/kube-scheduler.key"
        common_name: "system:kube-scheduler"
        organization_name: "system:kube-scheduler"

    - name: Sign certificate for kube-scheduler using CA servers private key
      community.crypto.x509_certificate:
        path: "{{ certs_path }}/kube-scheduler.crt"
        ownca_path: "{{ certs_path }}/k8s-ca.crt"
        ownca_privatekey_path: "{{ certs_path }}/k8s-ca.key"
        csr_path: "{{ certs_path }}/kube-scheduler.csr"
        provider: ownca

    # The Kubernetes API Server Certificate
    # The kube-apiserver certificate requires all names
    # that various components may reach it to be part of the alternate names.
    # These include the different DNS names, and IP addresses
    # such as the controlplane servers IP address, the load balancers IP address,
    # the kube-api service IP address etc.
    # These provide an identity for the certificate,
    # which is key in the SSL process for a server to prove who it is.

    - name: Generate Kubernetes API Server Certificate
      community.crypto.openssl_privatekey:
        path: "{{ certs_path }}/kube-apiserver.key"
        type: Ed25519

    - name: Generate a CSR for the Kubernetes API Server
      community.crypto.openssl_csr:
        path: "{{ certs_path }}/kube-apiserver.csr"
        privatekey_path: "{{ certs_path }}/kube-apiserver.key"
        basic_constraints_critical: true
        basic_constraints: "CA:FALSE"
        key_usage_critical: true
        key_usage:
          - nonRepudiation
          - digitalSignature
          - keyEncipherment
        extended_key_usage:
          - serverAuth
        common_name: "kube-apiserver"
        organization_name: "Kubernetes"
        subject_alt_name: |
          DNS:kubernetes;
          DNS:kubernetes.default;
          DNS:kubernetes.default.svc;
          DNS:kubernetes.default.svc.cluster;
          DNS:kubernetes.default.svc.cluster.local;
          IP:{{ api_service_ip }};
          IP:{{ controlplane01_ip }};
          IP:{{ controlplane02_ip }};
          IP:{{ loadbalancer_ip }};
          IP:127.0.0.1

    - name: Sign the CSR using the CA private key
      community.crypto.x509_certificate:
        path: "{{ certs_path }}/kube-apiserver.crt"
        ownca_path: "{{ certs_path }}/k8s-ca.crt"
        ownca_privatekey_path: "{{ certs_path }}/k8s-ca.key"
        csr_path: "{{ certs_path }}/kube-apiserver.csr"
        provider: ownca

    # The API Server Kubelet Client Certificate
    # This certificate is for the API server to authenticate with the kubelets
    # when it requests information from them

    - name: Generate API Server Kubelet Client Certificate
      community.crypto.openssl_privatekey:
        path: "{{ certs_path }}/kube-apiserver-kubelet-client.key"
        type: Ed25519

    - name: Create CSR using the private key
      community.crypto.openssl_csr:
        path: "{{ certs_path }}/kube-apiserver-kubelet-client.csr"
        privatekey_path: "{{ certs_path }}/kube-apiserver-kubelet-client.key"
        common_name: "kube-apiserver-kubelet-client"
        organization_name: "Kubernetes"
        basic_constraints_critical: true
        basic_constraints: "CA:FALSE"
        key_usage_critical: true
        key_usage:
          - nonRepudiation
          - digitalSignature
          - keyEncipherment
        extended_key_usage:
          - clientAuth

    - name: Sign certificate for kube-apiserver-kubelet-client using CA servers private key
      community.crypto.x509_certificate:
        path: "{{ certs_path }}/kube-apiserver-kubelet-client.crt"
        ownca_path: "{{ certs_path }}/k8s-ca.crt"
        ownca_privatekey_path: "{{ certs_path }}/k8s-ca.key"
        csr_path: "{{ certs_path }}/kube-apiserver-kubelet-client.csr"
        provider: ownca

    # The ETCD Server Certificate
    # Similarly ETCD server certificate must have addresses of all the servers
    # part of the ETCD cluster. Similarly, this is a server certificate,
    # which is again all about proving identity.

    - name: Generate ETCD Server Certificate
      community.crypto.openssl_privatekey:
        path: "{{ certs_path }}/etcd-server.key"
        type: Ed25519

    - name: Create CSR using the private key for etcd-server
      community.crypto.openssl_csr:
        path: "{{ certs_path }}/etcd-server.csr"
        privatekey_path: "{{ certs_path }}/etcd-server.key"
        basic_constraints: "CA:FALSE"
        key_usage:
          - nonRepudiation
          - digitalSignature
          - keyEncipherment
        common_name: "etcd-server"
        organization_name: "Kubernetes"
        subject_alt_name: |
          DNS:localhost;
          IP:{{ controlplane01_ip }};
          IP:{{ controlplane02_ip }};
          IP:127.0.0.1

    - name: Sign certificate for etcd-server using CA servers private key
      community.crypto.x509_certificate:
        path: "{{ certs_path }}/etcd-server.crt"
        ownca_path: "{{ certs_path }}/k8s-ca.crt"
        ownca_privatekey_path: "{{ certs_path }}/k8s-ca.key"
        csr_path: "{{ certs_path }}/etcd-server.csr"
        provider: ownca

    # The Service Account Key Pair
    # The service account key pair is used by the API server to sign tokens
    # that are used by the kubelet to prove its identity.
    - name: Generate Service Account Key Pair
      community.crypto.openssl_privatekey:
        path: "{{ certs_path }}/service-account.key"
        type: Ed25519

    - name: Create CSR using the private key
      community.crypto.openssl_csr:
        path: "{{ certs_path }}/service-account.csr"
        privatekey_path: "{{ certs_path }}/service-account.key"
        common_name: "service-account"
        organization_name: "Kubernetes"

    - name: Sign certificate for service-account using CA servers private key
      community.crypto.x509_certificate:
        path: "{{ certs_path }}/service-account.crt"
        ownca_path: "{{ certs_path }}/k8s-ca.crt"
        ownca_privatekey_path: "{{ certs_path }}/k8s-ca.key"
        csr_path: "{{ certs_path }}/service-account.csr"
        provider: ownca

- name: Verify the PKI with cer_verify.sh
  run_once: true
  ansible.builtin.shell:
    cmd: "{{ certs_path }}/cert_verify.sh"
  args:
    chdir: "{{ certs_path }}"
    executable: /bin/bash
  register: cert_verify_output
  changed_when: false

- name: Display the output of the certificate verification
  ansible.builtin.debug:
    msg: "{{ cert_verify_output.stdout_lines }}"
